<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FMSC 2025 - Match Management</title>
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="match-management-manifest.json">
    <meta name="theme-color" content="#03bded">
    <link rel="icon" type="image/svg+xml" href="Tounament logo.svg">
    <link rel="apple-touch-icon" href="icon-192x192.png">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Bebas+Neue&display=swap" rel="stylesheet">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.4.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.4.0/firebase-database-compat.js"></script>
    
    <style>
        :root {
            --primary-color: #03bded;
            --secondary-color: #029ac0;
            --accent-color: #ff6b35;
            --text-color: #fff;
            --bg-color: #0a0b0c;
            --card-bg: #1a1d21;
            --border-color: #2a2f35;
            --group-a: #ff6b35;
            --group-b: #4ecdc4;
            --group-c: #45b7d1;
            --group-d: #96ceb4;
            --success-color: #44ff44;
            --warning-color: #ffaa00;
            --error-color: #ff4444;
            --modal-bg: rgba(26, 29, 33, 0.95);
            --modal-content-bg: #1a1d21;
            --shadow-color: rgba(0, 0, 0, 0.3);
            --backdrop-filter: blur(20px);
        }

        [data-theme="light"] {
            --primary-color: #0288d1;
            --secondary-color: #0277bd;
            --accent-color: #e64a19;
            --text-color: #333;
            --bg-color: #f5f5f5;
            --card-bg: #ffffff;
            --border-color: #e0e0e0;
            --group-a: #e64a19;
            --group-b: #26a69a;
            --group-c: #1976d2;
            --group-d: #66bb6a;
            --success-color: #2e7d32;
            --warning-color: #f57c00;
            --error-color: #d32f2f;
            --modal-bg: rgba(255, 255, 255, 0.95);
            --modal-content-bg: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.15);
            --backdrop-filter: blur(10px);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            transition: all 0.3s ease;
        }

        body:not([data-theme="light"]) {
            background: 
                radial-gradient(ellipse at top, rgba(3, 189, 237, 0.3) 0%, transparent 50%),
                radial-gradient(ellipse at bottom, rgba(255, 107, 53, 0.3) 0%, transparent 50%),
                linear-gradient(135deg, #0a0b0c 0%, #1a1d21 50%, #2a2f35 100%);
        }

        [data-theme="light"] body {
            background: 
                radial-gradient(ellipse at top, rgba(2, 136, 209, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at bottom, rgba(230, 74, 25, 0.1) 0%, transparent 50%),
                linear-gradient(135deg, #f5f5f5 0%, #ffffff 50%, #fafafa 100%);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px 0;
            background: rgba(26, 29, 33, 0.3);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        [data-theme="light"] .header {
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px var(--shadow-color);
        }

        .tournament-title {
            font-family: 'Bebas Neue', cursive;
            font-size: 3.5rem;
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--accent-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 1.5rem;
            opacity: 0.9;
            font-weight: 300;
            color: rgba(255, 255, 255, 0.8);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        [data-theme="light"] .subtitle {
            color: rgba(0, 0, 0, 0.6);
        }

        .matches-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .match-tile {
            background: rgba(26, 29, 33, 0.4);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        [data-theme="light"] .match-tile {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            box-shadow: 0 8px 32px var(--shadow-color);
        }

        .match-tile:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(3, 189, 237, 0.2);
            border-color: rgba(3, 189, 237, 0.3);
        }

        .match-header {
            padding: 20px;
            cursor: pointer;
            position: relative;
        }

        .match-header-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            width: 100%;
        }

        .match-info {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }

        .match-number {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.3rem;
            color: var(--primary-color);
            letter-spacing: 1px;
            font-weight: 700;
        }

        .match-group {
            color: var(--accent-color);
        }

        .match-separator {
            color: rgba(255, 255, 255, 0.3);
            font-size: 1.2rem;
            flex: 1;
            text-align: center;
            position: relative;
        }

        [data-theme="light"] .match-separator {
            color: rgba(0, 0, 0, 0.4);
        }

        .match-separator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.2), transparent);
            transform: translateY(-50%);
        }

        [data-theme="light"] .match-separator::before {
            background: linear-gradient(to right, transparent, rgba(0, 0, 0, 0.15), transparent);
        }

        .match-date-time {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.95rem;
            font-weight: 600;
            color: var(--text-color);
            white-space: nowrap;
        }

        [data-theme="light"] .match-date-time {
            background: rgba(0, 0, 0, 0.08);
            border: 1px solid var(--border-color);
        }

        .teams-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }

        .team {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
        }

        [data-theme="light"] .team {
            background: rgba(0, 0, 0, 0.03);
            border: 1px solid var(--border-color);
        }

        .team.team-right {
            flex-direction: row-reverse;
        }

        .team-logo {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 10px rgba(3, 189, 237, 0.3);
        }

        .team-name {
            font-weight: 600;
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.9);
        }

        [data-theme="light"] .team-name {
            color: var(--text-color);
        }

        .vs-separator {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.5rem;
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0 15px;
        }

        .match-score {
            text-align: center;
            margin: 0 15px;
        }

        .match-score .score {
            font-family: 'Bebas Neue', cursive;
            font-size: 2rem;
            font-weight: bold;
            color: var(--success-color);
            display: block;
            line-height: 1;
        }

        .match-score .finished-label {
            font-size: 0.7rem;
            color: var(--success-color);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            opacity: 0.8;
        }

        .match-status {
            text-align: center;
            margin: 0 15px;
        }

        .match-status .status-label {
            font-size: 0.9rem;
            color: var(--warning-color);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 4px 8px;
            border: 1px solid var(--warning-color);
            border-radius: 4px;
            background: rgba(255, 193, 7, 0.1);
        }

        /* Knockout Stage Styling */
        .knockout-team {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.1), rgba(3, 189, 237, 0.1));
            border: 1px solid var(--accent-color);
            position: relative;
        }

        .knockout-team::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, var(--accent-color), var(--primary-color));
            opacity: 0.05;
            border-radius: 12px;
            pointer-events: none;
        }

        .knockout-loading {
            background: linear-gradient(135deg, rgba(255, 107, 53, 0.2), rgba(3, 189, 237, 0.2));
            border-radius: 8px;
            padding: 10px;
        }

        .knockout-placeholder {
            color: var(--accent-color);
            font-weight: 600;
            font-style: italic;
            font-size: 0.9rem;
        }

        [data-theme="light"] .knockout-placeholder {
            color: var(--secondary-color);
        }

        /* Quarter Finals specific styling */
        .match-tile:has(.knockout-team) .match-group:contains("Quarter Final") {
            background: linear-gradient(135deg, var(--accent-color), var(--primary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .finished-match {
            border-left: 4px solid var(--success-color) !important;
        }

        .ongoing-match {
            border-left: 4px solid var(--warning-color) !important;
        }

        .match-type {
            text-align: center;
            margin-top: 15px;
            font-size: 0.9rem;
            color: var(--accent-color);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .expand-icon {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 1.5rem;
            color: var(--primary-color);
            transition: transform 0.3s ease;
        }

        .match-tile.expanded .expand-icon {
            transform: rotate(180deg);
        }

        .match-details {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: rgba(0, 0, 0, 0.2);
        }

        [data-theme="light"] .match-details {
            background: rgba(0, 0, 0, 0.05);
        }

        .match-tile.expanded .match-details {
            max-height: 500px;
        }

        .match-details-content {
            padding: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        [data-theme="light"] .match-details-content {
            border-top: 1px solid var(--border-color);
        }

        .goal-scorers-section {
            margin-bottom: 20px;
        }

        .goal-scorers-title {
            font-family: 'Bebas Neue', cursive;
            font-size: 1.2rem;
            color: var(--primary-color);
            margin-bottom: 15px;
            text-align: center;
            letter-spacing: 1px;
        }

        .goal-scorers-container {
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }

        .team-scorers {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
        }

        [data-theme="light"] .team-scorers {
            background: rgba(0, 0, 0, 0.05);
        }

        .team-scorers-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .team-logo-small {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            object-fit: cover;
        }

        .team-name-small {
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-color);
        }

        .scorer-list {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .scorer-item-small {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            padding: 4px 0;
        }

        .scorer-name {
            flex: 1;
            color: var(--text-color);
        }

        .scorer-jersey {
            color: var(--accent-color);
            font-weight: 600;
            min-width: 30px;
        }

        .scorer-events {
            display: flex;
            align-items: center;
            gap: 4px;
            margin-left: auto;
        }

        .scorer-goals {
            background: var(--success-color);
            color: var(--bg-color);
            border-radius: 50%;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
        }

        .scorer-own-goals {
            background: var(--error-color);
            color: white;
            border-radius: 10px;
            padding: 2px 6px;
            font-size: 0.6rem;
            font-weight: bold;
            white-space: nowrap;
        }

        .scorer-yellow-cards {
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .scorer-red-cards {
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .no-scorers {
            color: var(--text-color);
            opacity: 0.6;
            font-style: italic;
            font-size: 0.8rem;
            text-align: center;
            padding: 10px;
        }

        .motm-section {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            margin-top: 15px;
            text-align: center;
        }

        [data-theme="light"] .motm-section {
            background: rgba(255, 215, 0, 0.05);
        }

        .motm-title {
            font-size: 0.7rem;
            color: #ffd700;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        .motm-player {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.8rem;
            color: var(--text-color);
        }

        .motm-team {
            color: var(--primary-color);
            font-weight: 600;
        }

        .match-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        .action-btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }

        .action-btn:hover {
            background: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(3, 189, 237, 0.3);
        }

        .action-btn.manage {
            background: var(--primary-color);
        }

        .action-btn.manage:hover {
            background: var(--secondary-color);
        }

        .loading-team {
            display: flex;
            align-items: center;
            gap: 8px;
            opacity: 0.6;
        }

        .loading-dots {
            display: flex;
            gap: 4px;
        }

        .loading-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary-color), var(--accent-color));
            animation: loadingAnimation 1.5s infinite;
        }

        .loading-dot:nth-child(2) { animation-delay: 0.3s; }
        .loading-dot:nth-child(3) { animation-delay: 0.6s; }

        @keyframes loadingAnimation {
            0%, 80%, 100% { opacity: 0.3; transform: scale(0.8); }
            40% { opacity: 1; transform: scale(1.2); }
        }

        .tbd-text {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
        }

        [data-theme="light"] .tbd-text {
            color: rgba(0, 0, 0, 0.5);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 15px;
            }

            .tournament-title {
                font-size: 2.5rem;
            }

            .matches-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .teams-container {
                flex-direction: row;
                gap: 10px;
                align-items: center;
                justify-content: space-between;
            }

            .team {
                flex: 1;
                min-width: 0; /* Allow flex items to shrink */
                padding: 10px;
            }

            .team.team-right {
                flex-direction: row;
            }

            .vs-separator {
                font-size: 1.2rem;
                margin: 0 8px;
            }

            .match-score {
                margin: 0 8px;
            }

            .match-score .score {
                font-size: 1.5rem;
            }

            .match-score .finished-label {
                font-size: 0.6rem;
            }

            .match-status {
                margin: 0 8px;
            }

            .match-status .status-label {
                font-size: 0.8rem;
                padding: 2px 6px;
            }

            .team-logo {
                width: 32px;
                height: 32px;
            }

            .team-name {
                font-size: 0.85rem;
                line-height: 1.2;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }
        }

        /* Floating particles animation */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(2px 2px at 20px 30px, rgba(3, 189, 237, 0.3), transparent),
                radial-gradient(2px 2px at 40px 70px, rgba(255, 107, 53, 0.3), transparent),
                radial-gradient(1px 1px at 90px 40px, rgba(78, 205, 196, 0.3), transparent);
            animation: float 20s infinite linear;
            pointer-events: none;
        }

        @keyframes float {
            0% { transform: translate(0, 0); }
            25% { transform: translate(-20px, -10px); }
            50% { transform: translate(20px, -20px); }
            75% { transform: translate(-10px, 10px); }
            100% { transform: translate(0, 0); }
        }

        .navigation-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .nav-button {
            padding: 12px 20px;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            border: none;
            border-radius: 25px;
            color: white;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 15px rgba(3, 189, 237, 0.3);
            position: relative;
            overflow: hidden;
        }

        .nav-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(3, 189, 237, 0.5);
            background: linear-gradient(135deg, var(--secondary-color), var(--primary-color));
        }

        .nav-button:active {
            transform: translateY(0);
        }

        .nav-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .nav-button:hover::before {
            left: 100%;
        }

        @media (max-width: 768px) {
            .navigation-buttons {
                gap: 10px;
                padding: 0 15px;
            }
            
            .nav-button {
                padding: 10px 16px;
                font-size: 0.8rem;
                min-width: 120px;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="version-info" style="position: fixed; top: 10px; right: 10px; background: var(--modal-content-bg); backdrop-filter: var(--backdrop-filter); padding: 8px 12px; border-radius: 8px; font-size: 0.8rem; z-index: 1000; border: 1px solid var(--primary-color); display: flex; align-items: center; gap: 8px;">
            <span id="app-version" style="color: var(--primary-color); font-weight: bold;">v4.0</span>
            <button id="theme-toggle" onclick="toggleTheme()" style="padding: 4px 8px; font-size: 0.7rem; background: var(--secondary-color); border: none; border-radius: 4px; color: white; cursor: pointer; transition: all 0.3s ease;" title="Toggle light/dark mode">🌙</button>
            <button onclick="clearAppCache()" style="padding: 4px 8px; font-size: 0.7rem; background: var(--primary-color); border: none; border-radius: 4px; color: white; cursor: pointer;" title="Clear cache and refresh">🔄</button>
        </div>
        <div class="header">
            <h1 class="tournament-title">FMSC 2025</h1>
            <p class="subtitle">Match Management</p>
        </div>

        <div class="navigation-buttons">
            <a href="top-scorers.html" class="nav-button">
                🏆 Top Scorers
            </a>
            <a href="card-penalties.html" class="nav-button">
                🟨🟥 Card Penalties
            </a>
            <a href="team-standings.html" class="nav-button">
                📊 Team Standings
            </a>
        </div>

        <div class="matches-grid" id="matches-grid">
            <!-- Matches will be populated here -->
        </div>
    </div>

    <script>
        // Theme Management
        function initializeTheme() {
            const savedTheme = localStorage.getItem('fmsc-theme') || 'dark';
            applyTheme(savedTheme);
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            applyTheme(newTheme);
            localStorage.setItem('fmsc-theme', newTheme);
        }

        function applyTheme(theme) {
            if (theme === 'light') {
                document.documentElement.setAttribute('data-theme', 'light');
                document.getElementById('theme-toggle').textContent = '☀️';
                document.getElementById('theme-toggle').title = 'Switch to dark mode';
            } else {
                document.documentElement.removeAttribute('data-theme');
                document.getElementById('theme-toggle').textContent = '🌙';
                document.getElementById('theme-toggle').title = 'Switch to light mode';
            }
        }

        // Initialize theme on page load
        document.addEventListener('DOMContentLoaded', initializeTheme);

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyCapatOZLxm387yKpFUPD-K8Dv24UBcP9k",
            authDomain: "exvertixe-futsal.firebaseapp.com",
            databaseURL: "https://exvertixe-futsal-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "exvertixe-futsal",
            storageBucket: "exvertixe-futsal.firebasestorage.app",
            messagingSenderId: "992942970225",
            appId: "1:992942970225:web:25bd160a3ac2139b5612d0",
            measurementId: "G-130DYDBMF6"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        let teams = {};
        let drawAssignments = {};
        let matchStates = {};
        let matchScores = {};
        let matchEvents = {};
        let teamLists = {};
        let matchMotm = {};
        let quarterFinalDraw = {};
        let knockoutResults = {};

        // Match schedule data - Updated for October 26-28, 2025
        // Group A: 4 teams, Group B: 3 teams, Group C: 3 teams, Group D: 3 teams
        const matchSchedule = {
            'October 26': [
                { teams: ['A1', 'A2'], type: 'Group A', time: '4:00 PM' },
                { teams: ['A3', 'A4'], type: 'Group A', time: '5:00 PM' },
                { teams: ['B1', 'B2'], type: 'Group B', time: '8:00 PM' },
                { teams: ['C1', 'C2'], type: 'Group C', time: '9:00 PM' },
                { teams: ['D1', 'D2'], type: 'Group D', time: '10:00 PM' }
            ],
            'October 27': [
                { teams: ['D1', 'D3'], type: 'Group D', time: '4:00 PM' },
                { teams: ['C1', 'C3'], type: 'Group C', time: '5:00 PM' },
                { teams: ['B1', 'B3'], type: 'Group B', time: '8:00 PM' },
                { teams: ['A1', 'A3'], type: 'Group A', time: '9:00 PM' },
                { teams: ['A2', 'A4'], type: 'Group A', time: '10:00 PM' }
            ],
            'October 28': [
                { teams: ['B2', 'B3'], type: 'Group B', time: '4:00 PM' },
                { teams: ['C2', 'C3'], type: 'Group C', time: '5:00 PM' },
                { teams: ['D2', 'D3'], type: 'Group D', time: '8:00 PM' },
                { teams: ['A2', 'A3'], type: 'Group A', time: '9:00 PM' },
                { teams: ['A1', 'A4'], type: 'Group A', time: '10:00 PM' }
            ],
            'October 29': [
                { teams: ['QF1_TEAM1', 'QF1_TEAM2'], type: 'Quarter Final 1', time: '4:00 PM', isKnockout: true, knockoutId: 'QF1' },
                { teams: ['QF2_TEAM1', 'QF2_TEAM2'], type: 'Quarter Final 2', time: '5:00 PM', isKnockout: true, knockoutId: 'QF2' },
                { teams: ['QF3_TEAM1', 'QF3_TEAM2'], type: 'Quarter Final 3', time: '8:00 PM', isKnockout: true, knockoutId: 'QF3' },
                { teams: ['QF4_TEAM1', 'QF4_TEAM2'], type: 'Quarter Final 4', time: '9:00 PM', isKnockout: true, knockoutId: 'QF4' }
            ],
            'October 30': [
                { teams: ['SF1_TEAM1', 'SF1_TEAM2'], type: 'Semi Final 1', time: '8:00 PM', isKnockout: true, knockoutId: 'SF1', dependsOn: ['QF1', 'QF2'] },
                { teams: ['SF2_TEAM1', 'SF2_TEAM2'], type: 'Semi Final 2', time: '9:00 PM', isKnockout: true, knockoutId: 'SF2', dependsOn: ['QF3', 'QF4'] }
            ],
            'October 31': [
                { teams: ['FINAL_TEAM1', 'FINAL_TEAM2'], type: 'Final', time: '8:00 PM', isKnockout: true, knockoutId: 'FINAL', dependsOn: ['SF1', 'SF2'] }
            ]
        };

        // Listen for draw assignments changes
        database.ref('drawAssignments').on('value', (snapshot) => {
            drawAssignments = snapshot.val() || {};
            renderMatches();
        });

        // Listen for team data changes
        database.ref('applications').on('value', (snapshot) => {
            teams = snapshot.val() || {};
            renderMatches();
        });

        // Listen for match states changes
        database.ref('matchState').on('value', (snapshot) => {
            matchStates = snapshot.val() || {};
            renderMatches();
        });

        // Listen for match scores changes
        database.ref('matchScores').on('value', (snapshot) => {
            matchScores = snapshot.val() || {};
            renderMatches();
        });

        // Listen for match events changes
        database.ref('matchEvents').on('value', (snapshot) => {
            matchEvents = snapshot.val() || {};
            renderMatches();
        });

        // Listen for team lists changes
        database.ref('teamLists').on('value', (snapshot) => {
            teamLists = snapshot.val() || {};
            renderMatches();
        });

        // Listen for match MOTM changes
        database.ref('matchMotm').on('value', (snapshot) => {
            matchMotm = snapshot.val() || {};
            renderMatches();
        });

        // Listen for quarter final draw changes
        database.ref('quarterFinalDraw').on('value', (snapshot) => {
            quarterFinalDraw = snapshot.val() || {};
            updateKnockoutMatches();
            renderMatches();
        });

        // Listen for knockout results changes
        database.ref('knockoutResults').on('value', (snapshot) => {
            knockoutResults = snapshot.val() || {};
            updateKnockoutMatches();
            renderMatches();
        });

        // Update knockout matches based on results
        function updateKnockoutMatches() {
            console.log('Updating knockout matches...');
            console.log('Quarter Final Draw:', quarterFinalDraw);
            console.log('Knockout Results:', knockoutResults);
            
            // Update match schedule with actual team names based on QF draw and results
            updateMatchScheduleWithKnockoutTeams();
        }

        // Function to get actual team names for knockout matches
        function updateMatchScheduleWithKnockoutTeams() {
            // Update Quarter Finals with actual teams from quarterFinalDraw
            for (const date in matchSchedule) {
                matchSchedule[date].forEach(match => {
                    if (match.isKnockout) {
                        updateKnockoutMatchTeams(match, date);
                    }
                });
            }
        }

        // Update individual knockout match with actual team names
        function updateKnockoutMatchTeams(match, date) {
            switch (match.knockoutId) {
                case 'QF1':
                case 'QF2':
                case 'QF3':
                case 'QF4':
                    updateQuarterFinalMatch(match);
                    break;
                case 'SF1':
                    updateSemiFinalMatch(match, ['QF1', 'QF2']);
                    break;
                case 'SF2':
                    updateSemiFinalMatch(match, ['QF3', 'QF4']);
                    break;
                case 'FINAL':
                    updateFinalMatch(match);
                    break;
            }
        }

        // Update quarter final match with teams from quarterFinalDraw
        function updateQuarterFinalMatch(match) {
            const qfData = quarterFinalDraw[match.knockoutId];
            if (qfData) {
                match.actualTeams = [
                    qfData.team1 || `${match.knockoutId}_TEAM1`,
                    qfData.team2 || `${match.knockoutId}_TEAM2`
                ];
                console.log(`Updated ${match.knockoutId} with teams:`, match.actualTeams);
            }
        }

        // Update semi-final match with winners from quarter finals
        function updateSemiFinalMatch(match, dependentQFs) {
            const [qf1Id, qf2Id] = dependentQFs;
            const qf1Winner = getMatchWinner(qf1Id);
            const qf2Winner = getMatchWinner(qf2Id);
            
            match.actualTeams = [
                qf1Winner || `${qf1Id}_WINNER`,
                qf2Winner || `${qf2Id}_WINNER`
            ];
            console.log(`Updated ${match.knockoutId} with teams:`, match.actualTeams);
        }

        // Update final match with winners from semi finals
        function updateFinalMatch(match) {
            const sf1Winner = getMatchWinner('SF1');
            const sf2Winner = getMatchWinner('SF2');
            
            match.actualTeams = [
                sf1Winner || 'SF1_WINNER',
                sf2Winner || 'SF2_WINNER'
            ];
            console.log(`Updated FINAL with teams:`, match.actualTeams);
        }

        // Get winner of a knockout match
        function getMatchWinner(knockoutId) {
            // Look for finished match in knockoutResults or matchStates
            const matchId = getKnockoutMatchId(knockoutId);
            if (!matchId) return null;
            
            // Check if match is finished
            if (matchStates[matchId] && matchStates[matchId].state === 'finished') {
                // Get final score
                let finalScore;
                if (matchScores[matchId] && matchScores[matchId].current) {
                    finalScore = matchScores[matchId].current;
                } else {
                    finalScore = calculateFinalScore(matchId);
                }
                
                // Determine winner
                if (finalScore.team1 > finalScore.team2) {
                    return getKnockoutTeam1(knockoutId);
                } else if (finalScore.team2 > finalScore.team1) {
                    return getKnockoutTeam2(knockoutId);
                }
                // If tied, could implement penalty shootout logic here
            }
            
            return null;
        }

        // Get the actual team1 for a knockout match
        function getKnockoutTeam1(knockoutId) {
            if (knockoutId.startsWith('QF')) {
                return quarterFinalDraw[knockoutId]?.team1;
            } else if (knockoutId === 'SF1') {
                return getMatchWinner('QF1');
            } else if (knockoutId === 'SF2') {
                return getMatchWinner('QF3');
            } else if (knockoutId === 'FINAL') {
                return getMatchWinner('SF1');
            }
            return null;
        }

        // Get the actual team2 for a knockout match
        function getKnockoutTeam2(knockoutId) {
            if (knockoutId.startsWith('QF')) {
                return quarterFinalDraw[knockoutId]?.team2;
            } else if (knockoutId === 'SF1') {
                return getMatchWinner('QF2');
            } else if (knockoutId === 'SF2') {
                return getMatchWinner('QF4');
            } else if (knockoutId === 'FINAL') {
                return getMatchWinner('SF2');
            }
            return null;
        }

        // Generate match ID for knockout matches
        function getKnockoutMatchId(knockoutId) {
            // Find the match in the schedule
            for (const date in matchSchedule) {
                const match = matchSchedule[date].find(m => m.knockoutId === knockoutId);
                if (match) {
                    return generateMatchId(date, match);
                }
            }
            return null;
        }

        // Check if a match ID belongs to a knockout match
        function isKnockoutMatch(matchId) {
            for (const date in matchSchedule) {
                const match = matchSchedule[date].find(m => {
                    return m.isKnockout && generateMatchId(date, m) === matchId;
                });
                if (match) return true;
            }
            return false;
        }

        // Get knockout stage type from match ID
        function getKnockoutStage(matchId) {
            for (const date in matchSchedule) {
                const match = matchSchedule[date].find(m => {
                    return m.isKnockout && generateMatchId(date, m) === matchId;
                });
                if (match) {
                    if (match.knockoutId.startsWith('QF')) return 'Quarter Final';
                    if (match.knockoutId.startsWith('SF')) return 'Semi Final';
                    if (match.knockoutId === 'FINAL') return 'Final';
                }
            }
            return 'Group Stage';
        }

        // Calculate final score from match events
        function calculateFinalScore(matchId) {
            const events = matchEvents[matchId] || {};
            let team1Score = 0;
            let team2Score = 0;

            Object.values(events).forEach(event => {
                if (event.eventType === 'goal') {
                    if (event.teamKey === 'team1') {
                        team1Score++;
                    } else if (event.teamKey === 'team2') {
                        team2Score++;
                    }
                } else if (event.eventType === 'own-goal') {
                    // Own goal counts for the opposing team
                    if (event.teamKey === 'team1') {
                        team2Score++;
                    } else if (event.teamKey === 'team2') {
                        team1Score++;
                    }
                }
            });

            return { team1: team1Score, team2: team2Score };
        }

        // Get team list for a team ID
        function getTeamList(teamId) {
            const teamName = teams[teamId]?.teamName;
            if (!teamName) return null;
            
            const teamListEntries = Object.entries(teamLists);
            const matchingEntry = teamListEntries.find(([key, teamList]) => 
                teamList.teamName === teamName
            );
            
            if (!matchingEntry) {
                const caseInsensitiveMatch = teamListEntries.find(([key, teamList]) => 
                    teamList.teamName && teamList.teamName.toLowerCase() === teamName.toLowerCase()
                );
                if (caseInsensitiveMatch) {
                    return caseInsensitiveMatch[1];
                }
                return null;
            }
            
            return matchingEntry[1];
        }

        // Get player data from team lists
        function getPlayerData(teamKey, personKey, matchId, eventPlayerName = null) {
            try {
                // Check if this is an official - officials should not be shown in match events
                if (personKey && personKey.toLowerCase().includes('official')) {
                    console.log(`Skipping official card event: personKey="${personKey}"`);
                    return null; // Return null to indicate this should be filtered out
                }
                
                // If event already contains player name, use it
                if (eventPlayerName && eventPlayerName !== 'N/A' && eventPlayerName.trim() !== '') {
                    console.log(`Using player name from event: "${eventPlayerName}"`);
                    return {
                        name: eventPlayerName,
                        jersey: personKey || 'N/A',
                        teamId: null,
                        teamName: 'From Event Data'
                    };
                }
                const matchParts = matchId.split('-');
                if (matchParts.length >= 2) {
                    const teamsMatch = matchParts[1].match(/^(.+)vs(.+)$/);
                    if (teamsMatch) {
                        const team1Position = teamsMatch[1];
                        const team2Position = teamsMatch[2];
                        const position = teamKey === 'team1' ? team1Position : team2Position;
                        
                        if (drawAssignments[position] && teams[drawAssignments[position]]) {
                            const teamId = drawAssignments[position];
                            const teamList = getTeamList(teamId);
                            
                            if (teamList && teamList.players) {
                                // Try direct access first
                                let player = teamList.players[personKey];
                                console.log(`Looking for player with personKey="${personKey}" in team ${teamId}`);
                                console.log(`Direct access result:`, player);
                                
                                // If not found, try searching by index or different key formats
                                if (!player) {
                                    const playerKeys = Object.keys(teamList.players);
                                    console.log(`Available player keys for ${teamId}:`, playerKeys);
                                    console.log(`Available player data:`, Object.fromEntries(
                                        playerKeys.slice(0, 5).map(key => [key, teamList.players[key]])
                                    ));
                                    
                                    // Try personKey as index
                                    const playerIndex = parseInt(personKey);
                                    if (!isNaN(playerIndex) && playerKeys[playerIndex]) {
                                        player = teamList.players[playerKeys[playerIndex]];
                                        console.log(`Found player by index ${playerIndex}:`, player);
                                    }
                                    
                                    // Try finding by different formats - more precise matching
                                    if (!player) {
                                        // Extract number from personKey (e.g., "player-10" -> "10")
                                        const personNumber = personKey.replace(/\D/g, ''); // Remove non-digits
                                        
                                        // Try exact number match first
                                        if (personNumber && playerKeys.includes(personNumber)) {
                                            player = teamList.players[personNumber];
                                            console.log(`Found player by exact number match "${personNumber}":`, player);
                                        }
                                        
                                        // Try exact key match
                                        if (!player) {
                                            const exactMatch = playerKeys.find(key => key === personKey);
                                            if (exactMatch) {
                                                player = teamList.players[exactMatch];
                                                console.log(`Found player by exact key match "${exactMatch}":`, player);
                                            }
                                        }
                                        
                                        // Only as last resort, try partial matching but with better logic
                                        if (!player && personNumber) {
                                            const partialMatch = playerKeys.find(key => key === personNumber || key.endsWith(personNumber));
                                            if (partialMatch) {
                                                player = teamList.players[partialMatch];
                                                console.log(`Found player by partial number match "${partialMatch}":`, player);
                                            }
                                        }
                                    }
                                }
                                
                                if (player && player.name) {
                                    console.log(`Successfully found player: ${player.name} #${player.jerseyNumber || player.jersey || 'N/A'}`);
                                    return {
                                        name: player.name,
                                        jersey: player.jerseyNumber || player.jersey || 'N/A',
                                        teamId: teamId,
                                        teamName: teams[teamId].teamName
                                    };
                                } else {
                                    console.log(`Player not found or invalid player data:`, player);
                                }
                            }
                            
                            console.log(`Player not found: teamKey=${teamKey}, personKey=${personKey}, teamId=${teamId}`);
                        }
                    }
                }
            } catch (error) {
                console.error('Error getting player data:', error);
            }
            
            console.log(`Fallback: Could not find player data for personKey="${personKey}"`);
            return {
                name: `Player ${personKey}`,
                jersey: 'N/A',
                teamId: null,
                teamName: 'Unknown Team'
            };
        }

        // Generate goal scorers section for a match
        function generateGoalScorersSection(matchId) {
            const events = matchEvents[matchId] || {};
            const team1Scorers = {};
            const team2Scorers = {};

            console.log(`Generating goal scorers for match ${matchId}`);
            console.log('Available events:', events);
            console.log('Event types found:', Object.values(events).map(e => e.eventType));

            // Process events to count goals by player
            Object.values(events).forEach(event => {
                if (event.eventType === 'goal') {
                    console.log('Processing goal event:', event);
                    console.log(`Goal event details: teamKey="${event.teamKey}", personKey="${event.personKey}", playerName="${event.playerName || event.name || 'N/A'}"`);
                    const playerData = getPlayerData(event.teamKey, event.personKey, matchId, event.playerName || event.name);
                    console.log('Retrieved player data:', playerData);
                    
                    // Skip if this is an official (should not happen for goals, but just in case)
                    if (!playerData) {
                        console.log('Skipping goal for invalid player data');
                        return;
                    }
                    
                    const playerKey = `${playerData.name}-${playerData.jersey}`;
                    
                    if (event.teamKey === 'team1') {
                        team1Scorers[playerKey] = team1Scorers[playerKey] || { ...playerData, goals: 0, ownGoals: 0, yellowCards: 0, redCards: 0 };
                        team1Scorers[playerKey].goals++;
                    } else if (event.teamKey === 'team2') {
                        team2Scorers[playerKey] = team2Scorers[playerKey] || { ...playerData, goals: 0, ownGoals: 0, yellowCards: 0, redCards: 0 };
                        team2Scorers[playerKey].goals++;
                    }
                } else if (event.eventType === 'own-goal') {
                    console.log('Processing own goal event:', event);
                    const playerData = getPlayerData(event.teamKey, event.personKey, matchId, event.playerName || event.name);
                    console.log('Own goal player data:', playerData);
                    
                    // Skip if this is an official (should not happen for own goals, but just in case)
                    if (!playerData) {
                        console.log('Skipping own goal for invalid player data');
                        return;
                    }
                    
                    const playerKey = `${playerData.name}-${playerData.jersey}`;
                    
                    if (event.teamKey === 'team1') {
                        team1Scorers[playerKey] = team1Scorers[playerKey] || { ...playerData, goals: 0, ownGoals: 0, yellowCards: 0, redCards: 0 };
                        team1Scorers[playerKey].ownGoals++;
                    } else if (event.teamKey === 'team2') {
                        team2Scorers[playerKey] = team2Scorers[playerKey] || { ...playerData, goals: 0, ownGoals: 0, yellowCards: 0, redCards: 0 };
                        team2Scorers[playerKey].ownGoals++;
                    }
                } else if (event.eventType === 'yellow') {
                    console.log('Processing yellow card event:', event);
                    const playerData = getPlayerData(event.teamKey, event.personKey, matchId, event.playerName || event.name);
                    
                    // Skip if this is an official card (playerData will be null)
                    if (!playerData) {
                        console.log('Skipping yellow card for official');
                        return;
                    }
                    
                    const playerKey = `${playerData.name}-${playerData.jersey}`;
                    
                    if (event.teamKey === 'team1') {
                        team1Scorers[playerKey] = team1Scorers[playerKey] || { ...playerData, goals: 0, ownGoals: 0, yellowCards: 0, redCards: 0 };
                        team1Scorers[playerKey].yellowCards++;
                    } else if (event.teamKey === 'team2') {
                        team2Scorers[playerKey] = team2Scorers[playerKey] || { ...playerData, goals: 0, ownGoals: 0, yellowCards: 0, redCards: 0 };
                        team2Scorers[playerKey].yellowCards++;
                    }
                } else if (event.eventType === 'red') {
                    console.log('Processing red card event:', event);
                    const playerData = getPlayerData(event.teamKey, event.personKey, matchId, event.playerName || event.name);
                    
                    // Skip if this is an official card (playerData will be null)
                    if (!playerData) {
                        console.log('Skipping red card for official');
                        return;
                    }
                    
                    const playerKey = `${playerData.name}-${playerData.jersey}`;
                    
                    if (event.teamKey === 'team1') {
                        team1Scorers[playerKey] = team1Scorers[playerKey] || { ...playerData, goals: 0, ownGoals: 0, yellowCards: 0, redCards: 0 };
                        team1Scorers[playerKey].redCards++;
                    } else if (event.teamKey === 'team2') {
                        team2Scorers[playerKey] = team2Scorers[playerKey] || { ...playerData, goals: 0, ownGoals: 0, yellowCards: 0, redCards: 0 };
                        team2Scorers[playerKey].redCards++;
                    }
                }
            });

            console.log('Team 1 scorers:', team1Scorers);
            console.log('Team 2 scorers:', team2Scorers);

            // Get MOTM data from separate database structure
            const motmData = matchMotm[matchId];
            console.log('MOTM data for match:', matchId, motmData);

            // Generate HTML
            const generateTeamScorers = (scorers, teamData) => {
                let scorersHtml = '';
                if (Object.keys(scorers).length === 0) {
                    scorersHtml = '<div class="no-scorers">No events recorded</div>';
                } else {
                    scorersHtml = Object.values(scorers)
                        .filter(scorer => scorer.goals > 0 || scorer.ownGoals > 0 || scorer.yellowCards > 0 || scorer.redCards > 0) // Show players with any events
                        .sort((a, b) => {
                            // Sort by goals first, then by total events
                            const aTotal = a.goals + a.ownGoals + a.yellowCards + a.redCards;
                            const bTotal = b.goals + b.ownGoals + b.yellowCards + b.redCards;
                            if (b.goals !== a.goals) return b.goals - a.goals; // Goals first
                            return bTotal - aTotal; // Then total events
                        })
                        .map(scorer => {
                            let eventBadges = '';
                            
                            // Add regular goals
                            if (scorer.goals > 0) {
                                eventBadges += `<span class="scorer-goals">${scorer.goals}</span>`;
                            }
                            
                            // Add own goals
                            if (scorer.ownGoals > 0) {
                                eventBadges += `<span class="scorer-own-goals">OG ${scorer.ownGoals}</span>`;
                            }
                            
                            // Add yellow cards
                            if (scorer.yellowCards > 0) {
                                eventBadges += `<span class="scorer-yellow-cards">🟨${scorer.yellowCards > 1 ? scorer.yellowCards : ''}</span>`;
                            }
                            
                            // Add red cards
                            if (scorer.redCards > 0) {
                                eventBadges += `<span class="scorer-red-cards">🟥${scorer.redCards > 1 ? scorer.redCards : ''}</span>`;
                            }
                            
                            return `
                                <div class="scorer-item-small">
                                    <span class="scorer-name">${scorer.name}</span>
                                    <span class="scorer-jersey">#${scorer.jersey}</span>
                                    <div class="scorer-events">${eventBadges}</div>
                                </div>
                            `;
                        }).join('');
                }

                return `
                    <div class="team-scorers">
                        <div class="scorer-list">
                            ${scorersHtml}
                        </div>
                    </div>
                `;
            };

            let motmHtml = '';
            if (motmData && motmData.playerName) {
                motmHtml = `
                    <div class="motm-section">
                        <div class="motm-title">Man of the Match</div>
                        <div class="motm-player">
                            <span>${motmData.playerName} #${motmData.jersey}</span>
                        </div>
                    </div>
                `;
            }

            return `
                <div class="goal-scorers-section">
                    <div class="goal-scorers-title">⚽ MATCH EVENTS</div>
                    <div class="goal-scorers-container">
                        ${generateTeamScorers(team1Scorers, null)}
                        ${generateTeamScorers(team2Scorers, null)}
                    </div>
                    ${motmHtml}
                </div>
            `;
        }

        function getTeamData(position) {
            if (!drawAssignments[position] || !teams[drawAssignments[position]]) {
                return null;
            }
            const teamId = drawAssignments[position];
            return {
                id: teamId,
                name: teams[teamId].teamName,
                logo: teams[teamId].teamName.replace(/[^a-zA-Z0-9\s]/g, '').replace(/\s+/g, '_').toLowerCase()
            };
        }

        function createTeamElement(position, isRight = false, isKnockout = false) {
            const teamData = getTeamData(position);
            const teamElement = document.createElement('div');
            teamElement.className = `team ${isRight ? 'team-right' : ''} ${isKnockout ? 'knockout-team' : ''}`;
            
            if (teamData && teamData.name) {
                const logoElement = document.createElement('img');
                logoElement.className = 'team-logo';
                logoElement.alt = teamData.name;
                logoElement.src = `logos/${teamData.logo}.jpg`;
                logoElement.onerror = () => {
                    logoElement.src = `logos/${teamData.logo}.png`;
                    logoElement.onerror = () => logoElement.style.display = 'none';
                };
                
                const nameElement = document.createElement('span');
                nameElement.className = 'team-name';
                nameElement.textContent = teamData.name;
                
                teamElement.appendChild(logoElement);
                teamElement.appendChild(nameElement);
            } else {
                // Handle knockout placeholders differently
                let placeholderText = position;
                let placeholderClass = 'tbd-text';
                
                if (isKnockout) {
                    placeholderClass += ' knockout-placeholder';
                    // Make placeholder text more descriptive for knockout stages
                    if (position.includes('WINNER')) {
                        placeholderText = position.replace('_', ' ').toLowerCase().replace(/\b\w/g, l => l.toUpperCase());
                    } else if (position.includes('QF') && position.includes('TEAM')) {
                        placeholderText = 'Awaiting QF Draw';
                    }
                }
                
                teamElement.innerHTML = `
                    <div class="loading-team ${isKnockout ? 'knockout-loading' : ''}">
                        ${isKnockout ? '' : `
                        <div class="loading-dots">
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                            <div class="loading-dot"></div>
                        </div>
                        `}
                        <span class="${placeholderClass}">${placeholderText}</span>
                    </div>
                `;
            }
            
            return teamElement;
        }

        function generateMatchId(date, match) {
            const dateStr = date.replace(/\s+/g, '').toLowerCase();
            
            // For knockout matches, use actual teams if available
            let team1, team2;
            if (match.isKnockout && match.actualTeams) {
                team1 = match.actualTeams[0];
                team2 = match.actualTeams[1];
            } else {
                team1 = match.teams[0];
                team2 = match.teams[1];
            }
            
            return `${dateStr}-${team1}vs${team2}-${match.time.replace(/[^0-9]/g, '')}`;
        }

        function renderMatches() {
            const container = document.getElementById('matches-grid');
            container.innerHTML = '';

            let matchCounter = 1;
            Object.keys(matchSchedule).forEach(date => {
                matchSchedule[date].forEach((match, index) => {
                    const matchTile = document.createElement('div');
                    matchTile.className = 'match-tile';
                    const matchId = generateMatchId(date, match);
                    matchTile.dataset.matchId = matchId;

                    // Use actual teams for knockout matches, fallback to placeholder teams
                    let team1Name, team2Name;
                    if (match.isKnockout && match.actualTeams) {
                        team1Name = match.actualTeams[0];
                        team2Name = match.actualTeams[1];
                    } else {
                        team1Name = match.teams[0];
                        team2Name = match.teams[1];
                    }
                    
                    const team1Element = createTeamElement(team1Name, false, match.isKnockout);
                    const team2Element = createTeamElement(team2Name, true, match.isKnockout);

                    // Check if match is finished and has a score
                    const matchState = matchStates[matchId];
                    const matchScore = matchScores[matchId];
                    const isFinished = matchState && matchState.state === 'finished';
                    
                    let separatorContent = '<span class="vs-separator">VS</span>';
                    let matchStatus = '';
                    
                    if (isFinished) {
                        let score1 = 0;
                        let score2 = 0;
                        
                        // First try to get scores from saved match scores
                        if (matchScore && matchScore.current) {
                            score1 = matchScore.current.team1 || 0;
                            score2 = matchScore.current.team2 || 0;
                        } else {
                            // Fallback to calculating from events
                            const calculatedScore = calculateFinalScore(matchId);
                            score1 = calculatedScore.team1;
                            score2 = calculatedScore.team2;
                        }
                        
                        separatorContent = `<div class="match-score">
                            <span class="score">${score1} - ${score2}</span>
                            <span class="finished-label">FINISHED</span>
                        </div>`;
                        matchTile.classList.add('finished-match');
                    } else if (matchState && matchState.state && matchState.state !== 'not-started') {
                        separatorContent = `<div class="match-status">
                            <span class="status-label">${matchState.state.toUpperCase()}</span>
                        </div>`;
                        matchTile.classList.add('ongoing-match');
                    }

                    matchTile.innerHTML = `
                        <div class="match-header" onclick="toggleMatch(this)">
                            <div class="match-header-line">
                                <div class="match-info">
                                    <span class="match-number">MATCH ${matchCounter} - <span class="match-group">${match.type}</span></span>
                                    <span class="match-separator"></span>
                                    <span class="match-date-time">${date} ${match.time}</span>
                                </div>
                                <div class="expand-icon">▼</div>
                            </div>
                            <div class="teams-container">
                                ${team1Element.outerHTML}
                                ${separatorContent}
                                ${team2Element.outerHTML}
                            </div>
                        </div>
                        <div class="match-details">
                            <div class="match-details-content">
                                ${generateGoalScorersSection(matchId)}
                                <div class="match-actions">
                                    <a href="match-detail.html?match=${encodeURIComponent(matchTile.dataset.matchId)}" class="action-btn manage">
                                        🎯 Manage Match
                                    </a>
                                </div>
                            </div>
                        </div>
                    `;

                    container.appendChild(matchTile);
                    matchCounter++;
                });
            });
        }

        function toggleMatch(header) {
            const matchTile = header.closest('.match-tile');
            matchTile.classList.toggle('expanded');
        }

        // Initial render
        updateKnockoutMatches(); // Set up knockout matches first
        renderMatches();

        // Debug functions for console testing
        window.testKnockoutSystem = function() {
            console.log('=== KNOCKOUT SYSTEM DEBUG ===');
            console.log('Quarter Final Draw:', quarterFinalDraw);
            console.log('Knockout Results:', knockoutResults);
            console.log('Match Schedule (Knockout Days):');
            
            ['October 29', 'October 30', 'October 31'].forEach(date => {
                if (matchSchedule[date]) {
                    console.log(`${date}:`, matchSchedule[date]);
                }
            });
        };

        window.simulateQFWinner = function(qfId, winnerTeam) {
            console.log(`Simulating ${qfId} winner: ${winnerTeam}`);
            // This would normally be handled by match results, but for testing:
            if (!knockoutResults[qfId]) knockoutResults[qfId] = {};
            knockoutResults[qfId].winner = winnerTeam;
            updateKnockoutMatches();
            renderMatches();
        };

        // Register Service Worker for PWA - Match Management Specific
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                // First, unregister any existing service workers that might conflict
                navigator.serviceWorker.getRegistrations().then(function(registrations) {
                    registrations.forEach(function(registration) {
                        if (registration.scope.includes('match-management') === false && 
                            !registration.scope.endsWith('/')) {
                            console.log('Unregistering conflicting SW:', registration.scope);
                            registration.unregister();
                        }
                    });
                });

                // Register our specific service worker
                navigator.serviceWorker.register('./match-management-sw.js', {
                    scope: './'
                })
                    .then(function(registration) {
                        console.log('Match Management SW registered with scope: ', registration.scope);
                        
                        // Check for updates
                        registration.addEventListener('updatefound', function() {
                            const newWorker = registration.installing;
                            if (newWorker) {
                                console.log('New service worker found, updating...');
                                newWorker.addEventListener('statechange', function() {
                                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                        console.log('New content is available, reloading...');
                                        window.location.reload();
                                    }
                                });
                            }
                        });
                    }, function(err) {
                        console.log('Match Management SW registration failed: ', err);
                    });
            });

            // Listen for messages from service worker
            navigator.serviceWorker.addEventListener('message', function(event) {
                if (event.data && event.data.type === 'CACHE_CLEARED') {
                    console.log('Cache cleared, reloading...');
                    window.location.reload();
                }
            });
        }

        // Add manual cache clear function (for debugging)
        window.clearAppCache = function() {
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                navigator.serviceWorker.controller.postMessage({type: 'CLEAR_CACHE'});
            } else {
                // Fallback: clear browser caches
                if ('caches' in window) {
                    caches.keys().then(function(names) {
                        names.forEach(function(name) {
                            if (name.includes('match-management')) {
                                caches.delete(name);
                            }
                        });
                    }).then(function() {
                        window.location.reload();
                    });
                }
            }
        };

        // Debug function to check PWA status
        window.checkPWAStatus = function() {
            console.log('=== PWA Status Check ===');
            console.log('Current URL:', window.location.href);
            console.log('Display mode:', window.matchMedia('(display-mode: standalone)').matches ? 'standalone' : 'browser');
            console.log('Service Worker supported:', 'serviceWorker' in navigator);
            console.log('Manifest link:', document.querySelector('link[rel="manifest"]')?.href);
            
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(registrations => {
                    console.log('Active Service Workers:', registrations.length);
                    registrations.forEach((reg, index) => {
                        console.log(`SW ${index + 1}:`, reg.scope, reg.active?.scriptURL);
                    });
                });
            }
            
            console.log('======================');
        };

        // Clear app cache function
        function clearAppCache() {
            if (confirm('Clear all cached data and refresh the app?')) {
                // Clear localStorage
                localStorage.clear();
                // Reload the page
                window.location.reload(true);
            }
        }

        // Call debug function on load (remove in production)
        window.addEventListener('load', () => {
            setTimeout(checkPWAStatus, 2000);
        });
    </script>
</body>
</html>